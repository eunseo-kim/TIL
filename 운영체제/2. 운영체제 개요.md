​	

# 🌼운영체제 2. 운영체제 개요 - TIL(21.03.13)

### 1. 운영체제의 역할

> 운영체제는 컴퓨터 하드웨어를 효율적으로 관리하여 사용자와 응용프로그램에게 서비스를 제공한다.

1. **User Interface** : 사용자에게 편리성을 제공한다.
2. **Resource management** : 리소스를 관리하여 효율성을 높인다.

3. **Process and Thread management** : 프로세스(실행의 주체)를 관리한다.
4. **System management** : 시스템을 보호한다.

---

### 2. 운영체제의 구분

- **동시 사용자 수**에 의한 구분

  - Single-user system : 단일 사용자
    - 한 명의 사용자가 모든 시스템의 자원을 독점한다.
    - 자원 관리 및 시스템 보호 방식이 **간단하다.**
  - Multi-user system : 다중 사용자
    - 동시에 여러 사용자들이 시스템을 사용한다. 
      (따라서 각종 시스템 자원들에 대한 소유 권한 관리 必/멀티 태스킹 기능 필요/OS가 복잡함)
    - 서버, 클러스터 장비 등에 사용한다.

  ---

- **동시 실행 프로세스 수**에 의한 구분

  - Single-tasking system : 단일 작업
    - 시스템 내에 하나의 작업(프로세스)만 존재함 
      (하나의 프로그램 실행을 마치면 다른 프로그램을 실행)
    - OS의 구조가 간단함
  - Multi-tasking system (Multiprogramming system) : 다중 작업
    - 동시에 여러 작업(프로세스)의 수행이 가능
    - OS의 구조, 기능이 복잡함

  ---

- **작업 수행 방식**에 의한 구분

  - 순서 처리(OS라는 개념이 없던 시절)

    - 사용자가 직접 하드웨어를 관리해야 했음 (직접 기계어로 프로그램 작성)
    - 실행하는 작업들이 순차적으로 처리되어, 작업에 대한 준비 시간이 많이 필요했음. 
      (각 작업들의 방식이 달라서 컴퓨터가 각 작업마다 준비(세팅)해야 되는 시간이 필요했음)

  -  Batch processing system : 일괄 처리 시스템 

    - 모든 시스템을 중앙에서 관리 및 운영
    - 사용자들의 요청 작업을 일정 시간 모아두었다가 동일한 작업들이 일정 개수 모이면 해당 작업을 한꺼번에 처리함
    - **시스템 지향적** : 시스템 입장에서는 처리 효율이 향상됨
      그러나 사용자 입장에서는 긴 응답시간이 필요함
    -  생산성 저하(같은 유형의 작업들이 모이기까지 오랜 시간 기다려야됨)

    ---

  - Time-sharing system : 시분할 시스템

    - ![image](https://user-images.githubusercontent.com/67737432/111026647-a8c86700-842e-11eb-9dc6-636238dd984b.png)
    - 여러 사용자가 자원들 동시에 사용
    - **사용자 지향적** : 대화형(반응형) 시스템 + 단말기(화면을 그려주고 입력 전달해주는 수준의...) 사용이 가능해짐
    - 응답시간↓, 생산성↑ / 그러나... 통신 비용↑, 보안 문제↑, 동시 사용자 수가 많으면 개인 사용자 체감 속도 ↓

    ---

  - Personal Computing

    - 개인이 시스템을 독점하여 더이상 CPU 활용률을 고려하지 않아도 됨
    - OS가 multi 보다 단순함
    - 응답시간이 빨라졌지만, 아무래도 개인용이다 보니 성능은 떨어짐

    ---

  - Parallel Processing System

    - 단일 시스템 내에서 2개 이상의 **프로세서**를 사용
    - 프로세서(CPU)는 여러개, 단 메모리 같은 자원들은 서로 공유함(Tightly-coupled system)
    - CPU가 여러개여서 성능↑ / 하나가 고장나도 다른 CPU들에 의해 정상적인 동작이 가능(신뢰성↑)
    - **그러나 하나의 시스템에 넣을 수 있는 프로세서(CPU)의 개수가 제한적임**

    ---

  - Distributed processing system 

    - **그러면 하나의 시스템에 프로세서를 넣지 말고 그냥 컴퓨터를 여러개 붙이자!**
    - 네트워크를 기반으로 구축된 **병렬 처리 시스템**
    - 사용자들은 **분산 운영체제**를 통해 개인의 입장에서는 하나의 프로그램, 자원처럼 느끼면서 사용 가능(은폐성)
    - 자원 공유를 통해 높은 성능 + 각 구성 요소간 독립성 유지, 분산 운영체제를 통해 고 신뢰성 가능 / 그러나 구축 및 관리가 복잡하고 어려움

    ---

  - Real-time system

    - 작업 처리에 **제한 시간**이 자원 활용 효율보다 중요한 시스템
    - Hard real-time : 시간 제약을 못지키면 시스템에 치명적인 영향
    - Soft real-time : 동영상 재생 처럼 영향은 있지만 딱히 큰 문제는 X
    - No real-time

---

### 3. 운영체제의 구조

> ![image](https://user-images.githubusercontent.com/67737432/111026638-99e1b480-842e-11eb-8f11-a22d123e66a2.png)
>
> - **커널 : OS의 핵심 부분(메모리가 상주)**	
>   - 가장 빈번하게 사용되는 기능들을 담당함
>   - 커널 == 핵 == 관리자 프로그램 == 상주 프로그램 == 제어 프로그램 
> - **유틸리티(Utility)**
>   - 비상주 프로그램

1. **단일 구조** : 커널 안에 모든 모듈을 다 넣어버리는 구조
   - 장점 : 커널 내 모듈간 직접 통신이 가능함
   - 단점 : 커널이 거대해져서 유지보수(버스, 추가 기능 구현)가 어렵고
     한 모듈의 문제가 전체 시스템에 영향을 미칠 가능성 UP
2. **계층 구조** 
   - 장점 : 모듈화에 의해 계층간 검증/수정이 용의해짐
     설계와 구현이 단순해짐
   - 단점 : 단일구조보다 성능이 저하됨(원하는 기능 수행을 위해 여러 계층을 거쳐야 함)
3. **마이크로 커널 구조** : 커널에는 필수 프로그램만 담고 나머지는 사용자 영역에서 응용 프로그램처럼 처리
   - 커널의 크기를 최소화하여 커널에는 필수 기능만 포함시킴
   - 기타 기능은 사용자 영역에서 수행함

---

### 4. 운영체제의 기능

1. 프로세스(Process) 관리

   > 프로세스란, **커널에 등록된 실행 단위**로 한마디로 '실행 중인 프로그램'이다.

2. 프로세서(Processor) 관리
3. 메모리(Memory0 관리
4. 파일(File) 관리
5. 입출력(I/O) 관리
6. 보조 기억 장치 및 기타 주변장치 관리 등
